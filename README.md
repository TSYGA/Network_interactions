# Network_interactions
Лабораторная работа по предмету "Операционные ситемы", на тему "Сетевые взаимодействия"

# Условия задачи
В системе хранится текстовый файл, в котором записаны некоторые сообщения. Сообщения записаны по одному на строке. Сообщение состоит из нескольких частей, части разделены одним пробелом. В файле могут быть пустые строки, которые должны игнорироваться.

#### Строки исходного файла, считываемый клиентской программой, имеют следующий формат:
hh:mm:ss hh:mm:ss BBB Message

где:
* hh:mm:ss - время, например: 23:14:51
* BBB - целое безнаковое число, 0 <= BBB <= 4294967295
* Message - текст неограниченной длины, до конца строки.
* Части записи отделяются друг от друга пробелом (одним).

#### Каждое сообщение из исходного файла клиент отправляет на сервер в следующем виде:

* 4 байта - номер сообщения в исходном файле, целое 32-битное число в СЕТЕВОМ порядке байтов, индексация от 0.
* 1 байт - значение часов (hh, 0-23) первого времени,
* 1 байт - значение минут (mm, 0-59) первого времени,
* 1 байт - значение секунд (ss, 0-59) первого времени,
* 3 байта - значение часов, минут и секунд второго времени (так же как и первое),
* 4 байта - значение BBB, в СЕТЕВОМ порядке байтов,
* N+1 байт - N символов сообщения Message, а в конце передается дополнительно нулевой байт (как для конца строки) - маркер конца сообщения

## Часть I. Сетевые взаимодействия с помощью поточных протоколов.
### Задание 1
Необходимо реализовать сетевую программу (tcpclient.cpp), которая считывала бы все эти сообщения из текстового файла и передавала их на удаленный сервер, прослушивающий TCP порт.

Адрес и порт сервера, а также имя входного файла указываются как аргументы командной строки при запуске клиента, например:

tcpclient 192.168.50.7:9000 file1.txt

где: 
* tcpclient - имя исполняемого бинарного файла клиента (получен путем компиляции tcpclient.cpp)
* 192.168.50.7 - IPv4 адрес сервера
* 9000 - прослушиваемый сервером TCP-порт
* file1.txt - файл с сообщениями.

После успешного подключения клиент отправляет на сервер 3 байта: коды символов 'p', 'u' и 't'. Этим самым он сообщает серверу, что далее будут передаваться сообщения. Далее клиент передает на сервер сообщения, один за одним.

На каждое принятое сообщение сервер присылает клиенту два байта: коды символов 'o' и 'k'. Это подтверждает успешный прием сообщения сервером. Клиент может и не дожидаться получения "ok" от сервера на каждое сообщение, а отправлять сообщения подряд, а уже после их отправки дождаться от сервера получения нескольких "ok" подряд. Их придет столько же, сколько сообщений отправил клиент.

После передачи последнего сообщения клиент дожидается финального "ok", и завершается. Важно, что клиент НЕ ДОЛЖЕН завершиться раньше, чем получит от сервера подтверждение по последнему сообщению.

Сервер завершается, если клиент отправит на сервер сообщение содержащее в поле Message лишь 4 байта - служебное слово "stop". 

#### Примечания:
* Клиент должен быть реализован для ОС Windows
* Если клиенту не удалось подключиться к серверу, то он должен подождать 100 мс и повторить попытку подключения. После 10 неудачных попыток клиент завершается
* Клиент подключается только в начале работы и использует установленное подключение для передачи всех сообщений из файла, т.е. НЕ переподключается к серверу для передачи каждого отдельного сообщения из входного файла
* Сокет клиента работает в блокирующем режиме

### Задание 2
Необходимо реализовать на языке C/C++ сервер tcpserver.cpp. 
