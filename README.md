# Network_interactions
Лабораторная работа по предмету "Операционные ситемы", на тему "Сетевые взаимодействия"

# Условия задачи
В системе хранится текстовый файл, в котором записаны некоторые сообщения. Сообщения записаны по одному на строке. Сообщение состоит из нескольких частей, части разделены одним пробелом. В файле могут быть пустые строки, которые должны игнорироваться.

#### Строки исходного файла, считываемый клиентской программой, имеют следующий формат:
hh:mm:ss hh:mm:ss BBB Message

где:
* hh:mm:ss - время, например: 23:14:51
* BBB - целое безнаковое число, 0 <= BBB <= 4294967295
* Message - текст неограниченной длины, до конца строки.
* Части записи отделяются друг от друга пробелом (одним).

#### Каждое сообщение из исходного файла клиент отправляет на сервер в следующем виде:

* 4 байта - номер сообщения в исходном файле, целое 32-битное число в СЕТЕВОМ порядке байтов, индексация от 0.
* 1 байт - значение часов (hh, 0-23) первого времени,
* 1 байт - значение минут (mm, 0-59) первого времени,
* 1 байт - значение секунд (ss, 0-59) первого времени,
* 3 байта - значение часов, минут и секунд второго времени (так же как и первое),
* 4 байта - значение BBB, в СЕТЕВОМ порядке байтов,
* N+1 байт - N символов сообщения Message, а в конце передается дополнительно нулевой байт (как для конца строки) - маркер конца сообщения

## Часть I. Сетевые взаимодействия с помощью поточных протоколов.
### Задание 1
Необходимо реализовать сетевую программу (tcpclient.cpp), которая считывала бы все эти сообщения из текстового файла и передавала их на удаленный сервер, прослушивающий TCP порт.

Адрес и порт сервера, а также имя входного файла указываются как аргументы командной строки при запуске клиента, например:

tcpclient 192.168.50.7:9000 file1.txt

где: 
* tcpclient - имя исполняемого бинарного файла клиента (получен путем компиляции tcpclient.cpp)
* 192.168.50.7 - IPv4 адрес сервера
* 9000 - прослушиваемый сервером TCP-порт
* file1.txt - файл с сообщениями.

После успешного подключения клиент отправляет на сервер 3 байта: коды символов 'p', 'u' и 't'. Этим самым он сообщает серверу, что далее будут передаваться сообщения. Далее клиент передает на сервер сообщения, один за одним.

На каждое принятое сообщение сервер присылает клиенту два байта: коды символов 'o' и 'k'. Это подтверждает успешный прием сообщения сервером. Клиент может и не дожидаться получения "ok" от сервера на каждое сообщение, а отправлять сообщения подряд, а уже после их отправки дождаться от сервера получения нескольких "ok" подряд. Их придет столько же, сколько сообщений отправил клиент.

После передачи последнего сообщения клиент дожидается финального "ok", и завершается. Важно, что клиент НЕ ДОЛЖЕН завершиться раньше, чем получит от сервера подтверждение по последнему сообщению.

Сервер завершается, если клиент отправит на сервер сообщение содержащее в поле Message лишь 4 байта - служебное слово "stop". 

#### Примечания:
* Клиент должен быть реализован для ОС Windows
* Если клиенту не удалось подключиться к серверу, то он должен подождать 100 мс и повторить попытку подключения. После 10 неудачных попыток клиент завершается
* Клиент подключается только в начале работы и использует установленное подключение для передачи всех сообщений из файла, т.е. НЕ переподключается к серверу для передачи каждого отдельного сообщения из входного файла
* Сокет клиента работает в блокирующем режиме

### Задание 2
Необходимо реализовать на языке C/C++ сервер tcpserver.cpp. Сервер должен прослушивать TCP-порт, принимать входящие подключения от клиентов, а затем - принимать сообщения, передаваемые клиентами.

Номер прослушиваемого порта передается серверу при запуске как первый аргумент командной строки, например: 

tcpserver 9000 

где: 
* tcpserver - имя бинарного файла программы
* 9000 - номер TCP порта для прослушивания

На каждое полученное сообщение сервер отправляет клиенту подтверждение "ok", согласно спецификации протокола. Все полученные сообщения сервер распечатывает в файл msg.txt.

Каждое сообщение в msg.txt предваряется данными о клиенте: IP-адрес, двоеточие, порт клиента, пробел. Далее следует сообщение, которое распечатывается в таком же виде, как и было во входном файле клиента.

#### Примечания:
* Сокеты сервера работают в неблокирующем режиме.
* Сервер является однопоточной программой. Сервер должен обслуживать несколько одновременно подключенных клиентов. Механизм параллельного обслуживания: select
* Сервер должен быть реализован для ОС Linux.
* Если при запуске серверу не удалось открыть TCP-порт для прослушивания, то сервер распечатывает сообщение об ошибке и завершается.
* Номер сообщения, используемый в протоколе, носит только служебный характер и в файле msg.txt не фиксируется.

## Часть II. Сетевые взаимодействия с помощью дейтаграммных протоколов.
### Задание 1
Реализуйте программу udpclient.cpp, взаимодействующую с удаленным сервером по протоколу UDP. 

Программа запускается аналогично tcpclient, с указанием IP-адреса и порта удаленного сервера (но уже UDP-порта) и имени входного файла с сообщениями:

udpclient 192.168.50.7:8700 file1.txt

Программа считывает данные из входного файла и на каждую непустую строку формирует сообщение-дейтаграмму и отправляет ее на удаленный сервер. В одной дейтаграмме передается только одно сообщение.

В ответ на дейтаграмму от клиента сервер посылает клиенту дейтаграмму, содержащую 4-байтовые номера (в сетевом порядке) нескольких последних (не более 20) принятых сообщений. Номера записаны в теле дейтаграммы подряд как 32-битные числа.

Клиент должен повторять отправку дейтаграмм с сообщениями до тех пор, пока на сервер не будут загружены хотя бы 20 ЛЮБЫХ сообщений из исходного файла (Если в исходном файле хранится менее 20 сообщений, то на сервер должны быть отправлены ВСЕ сообщения).

Если от сервера поступила дайтаграмма-подтверждение, то клиент должен проанализировать полученную дейтаграмму и извлечь из нее номера сообщений. Клиент НЕ ДОЛЖЕН ПОВТОРНО посылать те сообщения, которые, по информации клиента, уже находятся на сервере.

Если от сервера не поступало никаких дейтаграмм в течение 100 мс, то клиент повторяет отправку сообщений, но только тех, которые, по его информации, отсутствуют на сервере. 

#### Примечания:
* UDP-клиент реализуется для ОС: Linux
* Сокет клиента работает в блокирующем режиме
* Клиент открывает сокет один раз, при запуске и не открывает никаких других UDP-сокетов. Для приема-передачи дейтаграмм используется только один сокет

### Задание 2
Реализуйте udpserver.cpp. 

Сервер прослушивает диапазон UDP-портов (несколько портов, чьи номера идут подряд). Первый и последний номер диапазона указываются как аргументы командной строки при запуске, например: 

udpserv 9001 9006

Клиенты могут отправлять дейтаграммы на любые прослушиваемые сервером порты. Одновременно может отправляться несколько дейтаграмм от разных клиентов.

Сервер сохраняет принятые сообщения в msg.txt (формат аналогичен tcpserver). Сервер должен обеспечивать отсутствие повторов в выходном файле. Повторами считаются сообщения с одинаковым номером (передается в начале дейтаграммы). Если взять два сообщения с разным номером, то их нужно считать разными, даже если все данные в сообщениях одинаковы. Порядок записи сообщений в msg.txt не имеет значения (допустим любой порядок).

Идентификатором клиента (ID) можно считать пару: IP-адрес+порт, с которого он отправляет дейтаграммы. Сервер хранит в памяти небольшую базу данных, содержащую информацию: ID клиента и номера принятых от него сообщений. На основании этих данных сервер может формировать ответы клиентам, а также проверять приходящие сообщения на повторность.

Если на сервер приходит сообщение с полем Message со значением stop (от любого из клиентов), то сервер, отправив клиенту подтверждение, завершается.

#### Примечания:
* Сервер реализуется для ОС: Windows
* UDP-сокеты сервера работают в неблокирующем режиме. Механизм параллельного обслуживания сокетов: WSAEvents
